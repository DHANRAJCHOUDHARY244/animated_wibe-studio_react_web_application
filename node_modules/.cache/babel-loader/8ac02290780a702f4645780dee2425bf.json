{"ast":null,"code":"var _s = $RefreshSig$();\n\n// to use gsap with locomative scroll we have to use scroller proxy provider by gsap\nimport gsap from 'gsap';\nimport ScrollTrigger from 'gsap/ScrollTrigger';\nimport React from 'react';\nimport { useEffect } from 'react';\nimport { Scroll, useLocomotiveScroll } from 'react-locomotive-scroll';\n\nconst ScrollTriggerProxy = () => {\n  _s();\n\n  // first let's get instance of locamative scroll\n  const {\n    scroll\n  } = useLocomotiveScroll(); //   register scroll trigger plugin\n\n  gsap.registerPlugin(ScrollTrigger);\n  useEffect(() => {\n    if (scroll) {\n      const element = scroll === null || scroll === void 0 ? void 0 : scroll.el; //locomative scrolling element, in our case it's app (main)\n\n      scroll.on('scroll', ScrollTrigger.update); //on scroll of locomative ,update scroll trigger\n      // let's use scroller proxy\n\n      ScrollTrigger.scrollerProxy(element, {\n        scrollTop(value) {\n          return arguments.length ? scroll.scrollTo(value, {\n            duration: 0,\n            disableLerp: true\n          }) : scroll.scroll.instance.scroll.y;\n        },\n\n        // we don't have to define a scrollLeft because we're only scrolling vertically.\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        },\n\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n        pinType: element.style.transform ? \"transform\" : \"fixed\"\n      });\n    }\n\n    return () => {\n      ScrollTrigger.addEventListener('refresh', () => scroll === null || scroll === void 0 ? void 0 : scroll.update());\n      ScrollTrigger.refresh();\n    };\n  }, [scroll]);\n  return null;\n};\n\n_s(ScrollTriggerProxy, \"IwiEG3ynQwo6uTnjwSbeeNjIY+M=\", false, function () {\n  return [useLocomotiveScroll];\n});\n\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"sources":["C:/Users/HP5CD/OneDrive/Desktop/dashboard/wibe-studio-starter-files/src/components/ScrollTriggerProxy.js"],"names":["gsap","ScrollTrigger","React","useEffect","Scroll","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","duration","disableLerp","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh"],"mappings":";;AAAA;AACA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,SAASC,MAAT,EAAiBC,mBAAjB,QAA4C,yBAA5C;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAChC;AACC,QAAM;AAAEC,IAAAA;AAAF,MAAaF,mBAAmB,EAAtC,CAF+B,CAGhC;;AACCL,EAAAA,IAAI,CAACQ,cAAL,CAAoBP,aAApB;AAEAE,EAAAA,SAAS,CAAC,MAAM;AACd,QAAII,MAAJ,EAAY;AACR,YAAME,OAAO,GAAGF,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEG,EAAxB,CADQ,CACoB;;AAC5BH,MAAAA,MAAM,CAACI,EAAP,CAAU,QAAV,EAAmBV,aAAa,CAACW,MAAjC,EAFQ,CAEiC;AACzC;;AACAX,MAAAA,aAAa,CAACY,aAAd,CAA4BJ,OAA5B,EAAqC;AACnCK,QAAAA,SAAS,CAACC,KAAD,EAAQ;AACf,iBAAOC,SAAS,CAACC,MAAV,GAAmBV,MAAM,CAACW,QAAP,CAAgBH,KAAhB,EAAuB;AAACI,YAAAA,QAAQ,EAAE,CAAX;AAAcC,YAAAA,WAAW,EAAE;AAA3B,WAAvB,CAAnB,GAA8Eb,MAAM,CAACA,MAAP,CAAcc,QAAd,CAAuBd,MAAvB,CAA8Be,CAAnH;AACD,SAHkC;;AAGhC;AACHC,QAAAA,qBAAqB,GAAG;AACtB,iBAAO;AAACC,YAAAA,GAAG,EAAE,CAAN;AAASC,YAAAA,IAAI,EAAE,CAAf;AAAkBC,YAAAA,KAAK,EAAEC,MAAM,CAACC,UAAhC;AAA4CC,YAAAA,MAAM,EAAEF,MAAM,CAACG;AAA3D,WAAP;AACD,SANkC;;AAOnC;AACAC,QAAAA,OAAO,EAACtB,OAAO,CAACuB,KAAR,CAAcC,SAAd,GAA0B,WAA1B,GAAwC;AARb,OAArC;AAUH;;AACD,WAAO,MAAM;AACXhC,MAAAA,aAAa,CAACiC,gBAAd,CAA+B,SAA/B,EAAyC,MAAI3B,MAAJ,aAAIA,MAAJ,uBAAIA,MAAM,CAAEK,MAAR,EAA7C;AACAX,MAAAA,aAAa,CAACkC,OAAd;AACD,KAHD;AAID,GApBQ,EAoBN,CAAC5B,MAAD,CApBM,CAAT;AAsBA,SAAO,IAAP;AACD,CA7BD;;GAAMD,kB;UAEeD,mB;;;KAFfC,kB;AA+BN,eAAeA,kBAAf","sourcesContent":["// to use gsap with locomative scroll we have to use scroller proxy provider by gsap\r\nimport gsap from 'gsap'\r\nimport ScrollTrigger from 'gsap/ScrollTrigger'\r\nimport React from 'react'\r\nimport { useEffect } from 'react'\r\nimport { Scroll, useLocomotiveScroll } from 'react-locomotive-scroll'\r\n\r\nconst ScrollTriggerProxy = () => {\r\n\t// first let's get instance of locamative scroll\r\n  const { scroll } = useLocomotiveScroll()\r\n\t//   register scroll trigger plugin\r\n  gsap.registerPlugin(ScrollTrigger)\r\n\r\n  useEffect(() => {\r\n    if (scroll) {\r\n        const element = scroll?.el; //locomative scrolling element, in our case it's app (main)\r\n        scroll.on('scroll',ScrollTrigger.update);//on scroll of locomative ,update scroll trigger\r\n        // let's use scroller proxy\r\n        ScrollTrigger.scrollerProxy(element, {\r\n          scrollTop(value) {\r\n            return arguments.length ? scroll.scrollTo(value, {duration: 0, disableLerp: true}) : scroll.scroll.instance.scroll.y;\r\n          }, // we don't have to define a scrollLeft because we're only scrolling vertically.\r\n          getBoundingClientRect() {\r\n            return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};\r\n          },\r\n          // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\r\n          pinType:element.style.transform ? \"transform\" : \"fixed\"\r\n        });\r\n    }\r\n    return () => {\r\n      ScrollTrigger.addEventListener('refresh',()=>scroll?.update())\r\n      ScrollTrigger.refresh()\r\n    }\r\n  }, [scroll])\r\n\r\n  return null\r\n}\r\n\r\nexport default ScrollTriggerProxy\r\n"]},"metadata":{},"sourceType":"module"}