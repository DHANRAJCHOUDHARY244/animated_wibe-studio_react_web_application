{"ast":null,"code":"// to use gsap with locomative scroll we have to use scroller proxy provider by gsap\nimport gsap from'gsap';import ScrollTrigger from'gsap/ScrollTrigger';import React from'react';import{useEffect}from'react';import{Scroll,useLocomotiveScroll}from'react-locomotive-scroll';var ScrollTriggerProxy=function ScrollTriggerProxy(){// first let's get instance of locamative scroll\nvar _useLocomotiveScroll=useLocomotiveScroll(),scroll=_useLocomotiveScroll.scroll;//   register scroll trigger plugin\ngsap.registerPlugin(ScrollTrigger);useEffect(function(){if(scroll){var element=scroll===null||scroll===void 0?void 0:scroll.el;//locomative scrolling element, in our case it's app (main)\nscroll.on('scroll',ScrollTrigger.update);//on scroll of locomative ,update scroll trigger\n// let's use scroller proxy\nScrollTrigger.scrollerProxy(element,{scrollTop:function scrollTop(value){return arguments.length?scroll.scrollTo(value,{duration:0,disableLerp:true}):scroll.scroll.instance.scroll.y;},// we don't have to define a scrollLeft because we're only scrolling vertically.\ngetBoundingClientRect:function getBoundingClientRect(){return{top:0,left:0,width:window.innerWidth,height:window.innerHeight};},// LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\npinType:element.style.transform?\"transform\":\"fixed\"});}return function(){ScrollTrigger.addEventListener('refresh',function(){return scroll===null||scroll===void 0?void 0:scroll.update();});ScrollTrigger.refresh();};},[scroll]);return null;};export default ScrollTriggerProxy;","map":{"version":3,"sources":["C:/Users/HP5CD/OneDrive/Desktop/dashboard/wibe-studio-starter-files/src/components/ScrollTriggerProxy.js"],"names":["gsap","ScrollTrigger","React","useEffect","Scroll","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","duration","disableLerp","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh"],"mappings":"AAAA;AACA,MAAOA,CAAAA,IAAP,KAAiB,MAAjB,CACA,MAAOC,CAAAA,aAAP,KAA0B,oBAA1B,CACA,MAAOC,CAAAA,KAAP,KAAkB,OAAlB,CACA,OAASC,SAAT,KAA0B,OAA1B,CACA,OAASC,MAAT,CAAiBC,mBAAjB,KAA4C,yBAA5C,CAEA,GAAMC,CAAAA,kBAAkB,CAAG,QAArBA,CAAAA,kBAAqB,EAAM,CAChC;AACC,yBAAmBD,mBAAmB,EAAtC,CAAQE,MAAR,sBAAQA,MAAR,CACD;AACCP,IAAI,CAACQ,cAAL,CAAoBP,aAApB,EAEAE,SAAS,CAAC,UAAM,CACd,GAAII,MAAJ,CAAY,CACR,GAAME,CAAAA,OAAO,CAAGF,MAAH,SAAGA,MAAH,iBAAGA,MAAM,CAAEG,EAAxB,CAA4B;AAC5BH,MAAM,CAACI,EAAP,CAAU,QAAV,CAAmBV,aAAa,CAACW,MAAjC,EAAyC;AACzC;AACAX,aAAa,CAACY,aAAd,CAA4BJ,OAA5B,CAAqC,CACnCK,SADmC,oBACzBC,KADyB,CAClB,CACf,MAAOC,CAAAA,SAAS,CAACC,MAAV,CAAmBV,MAAM,CAACW,QAAP,CAAgBH,KAAhB,CAAuB,CAACI,QAAQ,CAAE,CAAX,CAAcC,WAAW,CAAE,IAA3B,CAAvB,CAAnB,CAA8Eb,MAAM,CAACA,MAAP,CAAcc,QAAd,CAAuBd,MAAvB,CAA8Be,CAAnH,CACD,CAHkC,CAGhC;AACHC,qBAJmC,iCAIX,CACtB,MAAO,CAACC,GAAG,CAAE,CAAN,CAASC,IAAI,CAAE,CAAf,CAAkBC,KAAK,CAAEC,MAAM,CAACC,UAAhC,CAA4CC,MAAM,CAAEF,MAAM,CAACG,WAA3D,CAAP,CACD,CANkC,CAOnC;AACAC,OAAO,CAACtB,OAAO,CAACuB,KAAR,CAAcC,SAAd,CAA0B,WAA1B,CAAwC,OARb,CAArC,EAUH,CACD,MAAO,WAAM,CACXhC,aAAa,CAACiC,gBAAd,CAA+B,SAA/B,CAAyC,iBAAI3B,CAAAA,MAAJ,SAAIA,MAAJ,iBAAIA,MAAM,CAAEK,MAAR,EAAJ,EAAzC,EACAX,aAAa,CAACkC,OAAd,GACD,CAHD,CAID,CApBQ,CAoBN,CAAC5B,MAAD,CApBM,CAAT,CAsBA,MAAO,KAAP,CACD,CA7BD,CA+BA,cAAeD,CAAAA,kBAAf","sourcesContent":["// to use gsap with locomative scroll we have to use scroller proxy provider by gsap\r\nimport gsap from 'gsap'\r\nimport ScrollTrigger from 'gsap/ScrollTrigger'\r\nimport React from 'react'\r\nimport { useEffect } from 'react'\r\nimport { Scroll, useLocomotiveScroll } from 'react-locomotive-scroll'\r\n\r\nconst ScrollTriggerProxy = () => {\r\n\t// first let's get instance of locamative scroll\r\n  const { scroll } = useLocomotiveScroll()\r\n\t//   register scroll trigger plugin\r\n  gsap.registerPlugin(ScrollTrigger)\r\n\r\n  useEffect(() => {\r\n    if (scroll) {\r\n        const element = scroll?.el; //locomative scrolling element, in our case it's app (main)\r\n        scroll.on('scroll',ScrollTrigger.update);//on scroll of locomative ,update scroll trigger\r\n        // let's use scroller proxy\r\n        ScrollTrigger.scrollerProxy(element, {\r\n          scrollTop(value) {\r\n            return arguments.length ? scroll.scrollTo(value, {duration: 0, disableLerp: true}) : scroll.scroll.instance.scroll.y;\r\n          }, // we don't have to define a scrollLeft because we're only scrolling vertically.\r\n          getBoundingClientRect() {\r\n            return {top: 0, left: 0, width: window.innerWidth, height: window.innerHeight};\r\n          },\r\n          // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\r\n          pinType:element.style.transform ? \"transform\" : \"fixed\"\r\n        });\r\n    }\r\n    return () => {\r\n      ScrollTrigger.addEventListener('refresh',()=>scroll?.update())\r\n      ScrollTrigger.refresh()\r\n    }\r\n  }, [scroll])\r\n\r\n  return null\r\n}\r\n\r\nexport default ScrollTriggerProxy\r\n"]},"metadata":{},"sourceType":"module"}